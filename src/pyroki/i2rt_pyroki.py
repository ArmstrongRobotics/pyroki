import numpy as np
import torch
import jaxlie
import pyroki as pk
import pyroki.pyroki_snippets as pks
from scipy.spatial.transform import Rotation as R
# Pre-import these to register the robot description
import robot_descriptions
import robot_descriptions.yam_description
from robot_descriptions.loaders.yourdfpy import load_robot_description


class I2RTPyroki():
    def __init__(self, xarm=False):
        self.xarm = xarm
        if xarm:
            # Generated by starting rviz (this is expected to fail, but will populate rosparams first)
            #   export ALLOWED_TO_CONTROL_XARM=1 
            #   roslaunch vision plover_real_arm_controller.launch
            # rosparam get /robot_description_load > /home/armstrong/load_xarm7.urdf
            # python3 -c "print($(cat ~/load_xarm7.urdf))" > ~/fixed_xarm7.urdf
            # sed -i 's/\\//g; s/\"  /\"/g; s/  \"/\"/g' ~/fixed_xarm7.urdf
            from yourdfpy import URDF
            package_path = "/home/armstrong/catkin_ws/src/armstrong_hardware"
            urdf = URDF.load("/home/armstrong/pyroki/fixed_unload_xarm7.urdf", mesh_dir=package_path)
            # urdf = load_robot_description("yam_description")
            self.pyro = pk.Robot.from_urdf(urdf)
            self.ee_name = "left_tool0"
            self.ee_idx = self.pyro.links.names.index(self.ee_name)
        else:
            urdf = load_robot_description("yam_description")
            self.pyro = pk.Robot.from_urdf(urdf)
            self.ee_name = "link_6"
            self.ee_idx = self.pyro.links.names.index(self.ee_name)

        # Warmstart pyroik jit
        self.ik(np.eye(4))
        self.fk(np.random.random(self.pyro.joints.num_actuated_joints))

    def ik(self, ee_pose_matrix, initial_joint_angles=None, pos_weight=50.0, ori_weight=10.0):
        assert ee_pose_matrix.shape == (4, 4), "EE pose matrix must be 4x4, got shape: {}".format(ee_pose_matrix.shape)
        joints = pks.solve_ik(
            robot=self.pyro,
            target_link_name=self.ee_name,
            target_position=ee_pose_matrix[:3, 3],
            target_wxyz=R.from_matrix(ee_pose_matrix[:3, :3]).as_quat(scalar_first=True),
            initial_joint_angles=initial_joint_angles[::-1] if initial_joint_angles is not None else None,
            pos_weight=pos_weight,
            ori_weight=ori_weight
        )
        joints = joints[::-1]  # Return reverse joint order since pyroki uses reversed joint order
        DEBUG_IK_ERROR = False
        if DEBUG_IK_ERROR:
            solved_ee_pose = self.fk(joints)
            pos_error = ee_pose_matrix[:3, 3] - solved_ee_pose[:3, 3]
            rel_rot = ee_pose_matrix[:3, :3].T @ solved_ee_pose[:3, :3]
            rot_error = (np.trace(rel_rot) - 1) / 2
            rot_error = np.acos(max(-1.0, min(rot_error, 1.0))) 
            print("Pos error: ", pos_error, "rot deg: ", np.rad2deg(rot_error))
        return joints

    def fk(self, joints, as_matrix=True, ret_all=False):
        if isinstance(joints, torch.Tensor):
            joints = joints.cpu().numpy()
        # Add batch dimension if not present
        added_batch_dim = False
        if len(joints.shape) == 1:
            joints = joints[None, :]
            added_batch_dim = True
        assert joints.shape[-1] == self.pyro.joints.num_actuated_joints, "Joint dimension mismatch, input joints shape: {}, expected shape: {}".format(joints.shape, len(self.pyro.joints.names))
        transforms = self.pyro.forward_kinematics(joints[..., ::-1])          # Reverse joint order since pyroki uses reversed joint order
        if ret_all:
            assert as_matrix
            assert len(transforms.shape) == 3
            return [np.array(jaxlie.SE3(transforms[:, idx]).as_matrix()) for idx in range(transforms.shape[1])]
        ee_matrix = np.array(jaxlie.SE3(transforms[:, -1]).as_matrix())
        if as_matrix:
            ret = ee_matrix
        else:
            # Return as xyz + rot6d
            trans = ee_matrix[..., :3, 3]
            rotx = ee_matrix[..., :3, 0]
            roty = ee_matrix[..., :3, 1]
            ret = np.concatenate([trans, rotx, roty], axis=-1)
        if added_batch_dim:
            ret = ret[0]
        return ret
